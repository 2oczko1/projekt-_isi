[Enter your prompt here]

=== Project File Structure ===

contexts
├─ ApiContext.tsx
├─ AuthContext.tsx
└─ CartContext.tsx

=== File Contents ===

File: ApiContext.tsx
════════════════════════════════════════
```
import React, { createContext, useContext, useEffect, useState } from 'react';
import { ReactNode } from 'react';
import { UserService, MedicineService, OrderService, PaymentService } from '@/lib/api';
import OrderType from '@/app/checkout'; // lub inna ścieżka

type Props = {
  children: ReactNode;
};

export interface ApiContextType {
  userService: any;
  medicineService: any;
  orderService: any;
  paymentService: any;
}

const ApiContext = createContext<ApiContextType | undefined>(undefined);

export const ApiProvider = ({ children }: Props) => {
  // Przykładowa funkcja tworzenia zamówienia z tokenem Google

  const createOrder = async (orderData: typeof OrderType, token: string) => {
    const response = await fetch('http://192.168.56.1:8080/api/orders', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${token}`,  // token Google do backendu
      },
      body: JSON.stringify(orderData),
    }).then(res => res.json());
    if (!response.ok) {
      throw new Error('Failed to create order');
    }
    return response.json();
  };

  return (
     <ApiContext.Provider value={{ userService: UserService, 
  medicineService: MedicineService, 
  orderService: OrderService, 
  paymentService: PaymentService  }}>
      {children}
    </ApiContext.Provider>
  );
};
export const useApi = () => {
  const ctx = useContext(ApiContext);
  if (!ctx) throw new Error('useApi must be used within ApiProvider');
  return ctx;
};


```

File: AuthContext.tsx
════════════════════════════════════════
```
import React, { createContext, useContext, useState, useEffect } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { useApi } from './ApiContext'; // popraw ścieżkę jeśli inna
import type { User } from '@/types';


export interface AuthContextType {
  user: User | null;
  isAuthenticated: boolean;
  login: (email: string, password: string) => Promise<void>;
  register: (userData: any) => Promise<void>;
  logout: () => Promise<void>;
  updateUser: (userData: Partial<User>) => Promise<void>;
  accessToken: string | null;  // Nowy stan dla accessToken
  updateAccessToken: (token: string) => void;  // Funkcja do ustawiania tokenu

}

const AuthContext = createContext<AuthContextType | undefined>(undefined);


export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const { userService } = useApi();
  const [storedAccessToken, setStoredAccessToken] = useState<string | null>(null); // Stan dla accessToken


  useEffect(() => {
    loadStoredUser();
  }, []);

  // Function to load the stored user data from AsyncStorage
  const loadStoredUser = async () => {
    try {
      const storedUser = await AsyncStorage.getItem('@user');
      if (storedUser) {
        const parsedUser = JSON.parse(storedUser);
        setUser(parsedUser);
        console.log('Loaded user from AsyncStorage:', parsedUser);
      }
      const storedToken = await AsyncStorage.getItem('@accessToken');
      if (storedToken) {
        setStoredAccessToken(storedToken);
      }
    } catch (error) {
      console.error('Error loading stored user:', error);
    }
  };

  // Login function
  const login = async (email: string, password: string) => {
    try {
     const userData = await userService.authenticate(email, password);
      
      // Log the user data before saving to AsyncStorage
      console.log('User data after authentication:', userData);

      if (userData) {

        await AsyncStorage.setItem('@user', JSON.stringify(userData));
        setUser(userData);

      } else {
        console.log('Authentication failed, no user data received.');
      }
    } catch (error) {
      console.error('Login failed:', error);
      throw new Error('Login failed, please check your credentials');
    }
  };

  // Register function
  const register = async (userData: any) => {
    try {
      const newUser = await userService.create(userData);
      
      // Log the new user data before saving to AsyncStorage
      console.log('New user after registration:', newUser);

      if (newUser) {
        setUser(newUser);
        await AsyncStorage.setItem('@user', JSON.stringify(newUser));
      } else {
        console.log('Registration failed, no user data received.');
      }
    } catch (error) {
      console.error('Registration failed:', error);
      throw new Error('Registration failed, please try again');
    }
  };
  // Funkcja aktualizująca accessToken
  const updateAccessToken = (token: string) => {
    setStoredAccessToken(token); // Aktualizuje stan przechowujący token
    AsyncStorage.setItem('@accessToken', token);  // Zapisuje token w AsyncStorage
  };
  // Logout function
  const logout = async () => {
    try {
      setUser(null);
      setStoredAccessToken(null);
       await AsyncStorage.removeItem('@user');
      await AsyncStorage.removeItem('@accessToken');

      console.log('User logged out and removed from AsyncStorage');
    } catch (error) {
      console.error('Error logging out:', error);
    }
  };

  // Update user function
  const updateUser = async (userData: Partial<User>) => {
    try {
      if (user) {
        const updatedUser = await userService.update(user.id, userData);

        // Log the updated user data before saving to AsyncStorage
        console.log('Updated user data:', updatedUser);

        if (updatedUser) {
          setUser(updatedUser);
          await AsyncStorage.setItem('@user', JSON.stringify(updatedUser));
        } else {
          console.log('Failed to update user.');
        }
      }
    } catch (error) {
      console.error('Error updating user:', error);
      throw new Error('Failed to update user');
    }
  };

  const value = {
    user,
    isAuthenticated: !!user,
    login,
    register,
    logout,
    updateUser,
    accessToken: storedAccessToken, // Przechowuje token w kontekście
    updateAccessToken, // Udostępnia funkcję do ustawiania tokenu
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
}
export const useAuth = () => {
  const ctx = useContext(AuthContext);
  if (!ctx) throw new Error('useAuth must be used within AuthProvider');
  return ctx;
};


```

File: CartContext.tsx
════════════════════════════════════════
```
import React, { createContext, useContext, useState, useEffect } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';

interface CartItem {
  id: number;
  name: string;
  price: number;
  quantity: number;
  image?: string;
}

interface CartContextType {
  items: CartItem[];
  addItem: (item: CartItem) => void;
  removeItem: (id: number) => void;
  updateQuantity: (id: number, quantity: number) => void;
  clearCart: () => void;
  getTotal: () => number;
  getItemCount: () => number;
}

const CartContext = createContext<CartContextType | undefined>(undefined);

export function CartProvider({ children }: { children: React.ReactNode }) {
  const [items, setItems] = useState<CartItem[]>([]);

  useEffect(() => {
    loadStoredCart();
  }, []);

  useEffect(() => {
    saveCart();
  }, [items]);

  const loadStoredCart = async () => {
    try {
      const storedCart = await AsyncStorage.getItem('@cart');
      if (storedCart) {
        setItems(JSON.parse(storedCart));
      }
    } catch (error) {
      console.error('Error loading cart:', error);
    }
  };

  const saveCart = async () => {
    try {
      await AsyncStorage.setItem('@cart', JSON.stringify(items));
    } catch (error) {
      console.error('Error saving cart:', error);
    }
  };

  const addItem = (newItem: CartItem) => {
  if (!Number.isFinite(newItem.quantity) || newItem.quantity <= 0) {
    console.warn('Invalid quantity passed to addItem:', newItem.quantity);
    return;
  }

  setItems(prevItems => {
    const existingItem = prevItems.find(item => item.id === newItem.id);
    if (existingItem) {
      return prevItems.map(item =>
        item.id === newItem.id
          ? { ...item, quantity: item.quantity + newItem.quantity }
          : item
      );
    }
    return [...prevItems, newItem];
  });
};


  const removeItem = (id: number) => {
    setItems(prevItems => prevItems.filter(item => item.id !== id));
  };

  const updateQuantity = (id: number, quantity: number) => {
    if (quantity <= 0) {
      removeItem(id);
      return;
    }
    setItems(prevItems =>
      prevItems.map(item =>
        item.id === id ? { ...item, quantity } : item
      )
    );
  };

  const clearCart = () => {
    setItems([]);
  };

  const getTotal = () => {
    return items.reduce((total, item) => total + item.price * item.quantity, 0);
  };

  const getItemCount = () => {
    return items.reduce((count, item) => count + item.quantity, 0);
  };

  const value = {
    items,
    addItem,
    removeItem,
    updateQuantity,
    clearCart,
    getTotal,
    getItemCount,
  };

  return (
    <CartContext.Provider value={value}>
      {children}
    </CartContext.Provider>
  );
}

export function useCart() {
  const context = useContext(CartContext);
  if (!context) {
    throw new Error('useCart must be used within a CartProvider');
  }
  return context;
}
```
